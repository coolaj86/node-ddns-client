#!/usr/bin/env node
'use strict';

// dig -p 53 @ns1.redirect-www.org aj.daplie.me A
var testing = /ddns-testing/.test(process.argv[1]) ? true : false;

var fs = require('fs');
var path = require('path');
var cli = require('cli');
var hri = require('human-readable-ids').hri;
var ddns = require('../lib/ddns-client.js');

var freedomain = testing ? 'testing.letssecure.org' : '.daplie.me';
var configPath = path.join(require('os').homedir(), testing ? '.ddnsrc-testing.json' : '.ddnsrc.json' );

cli.parse({
  agree: [ false, "You agree to use Daplie DNS for good, not evil. You will not try to break stuff, hurt people, etc (we will notify you via email when more official legal terms become available on our website).", 'boolean', false ]
  //agree: [ false, 'Agree to the Daplie DNS terms of service. They are very friendly and available at https://daplie.com/dns#terms', 'boolean', false ]
, answer: [ 'a', 'The answer', 'string' ]
, cacert: [ false, 'specify a CA for "self-signed" https certificates', 'string' ]
, config: [ false, 'path to config file', 'string', configPath ]
, device: [ false, '(i.e. jobberwocky) use this if you have multiple devices that will all respond to this domain (i.e. dns round-robin)', 'string' ]
, email: [ false, 'we will keep your email safe and use it contact you when authenticated domain registration is available', 'email' ]
, hostname: [ 'h', "Pick your own subdomain of '" + freedomain + "' (note that unregistered domains can be claimed by anyone)", 'string' ]
, pathname: [ false, 'The api route to which to POST i.e. /api/ddns', 'string', '/api/com.daplie.dns/ddns' ]
, port: [ false, 'The port (default https/443)', 'number', 443 ]
, priority: [ 'p', 'The priority (for MX and other records)', 'string' ]
, random: [ false, "get a randomly assigned hostname such as 'rubber-duck-42." + freedomain + "'", 'boolean' ]
, services: [ 's', 'The service to use for updates i.e. ns1.example.org,ns2.example.org', 'string' ]
, token: [ false, 'Token', 'string' ]
, type: [ 't', 'The record type i.e. A, AAAA, MX, CNAME, ANAME, FWD, etc', 'string', 'A' ]
});

cli.main(function (args, cli) {
  var options = {};
  var answers;
  var tokenPath = path.join(__dirname, '..', 'tests', freedomain + '.jwt');

  var rc = {};

  try {
    rc = require(cli.config || configPath);
  } catch(e) {
    if (!cli.config) {
      console.error("Config file '" + configPath + "' could not be parsed.");
      return;
    }
  }

  Object.keys(cli).forEach(function (key) {
    options[key] = cli[key];
  });

  if (!cli.hostname) {
    cli.hostname = args[0];
    args.splice(0, 1);
  }
  if (cli.hostname && cli.random) {
    console.error("You may specify --hostname 'somedomain.example.com' or --random, but not both");
    return;
  }
  if (!(cli.hostname || cli.random || rc.hostname)) {
    console.error("You must specify either --hostname 'somedomain.example.com' or --random");
    return;
  }
  if (cli.random) {
    if (rc.hostname) {
      console.warn("[warn] ignoring --random because you already have a domain in '" + configPath + "'");
    }
  }
  options.hostname = cli.hostname || rc.hostname || hri.random();

  if (!/\./.test(options.hostname)) {
    options.hostname += '.' + freedomain.replace(/^\*/, '').replace(/^\./, '');
  }

  options.services = (cli.services||cli.service||'').split(',').filter(function (s) { return s; });
  if (!options.services.length) {
    options.services = rc.services || [];
  }

  if (!options.services.length) {
    options.services = [ 'ns1.redirect-www.org', 'ns2.redirect-www.org' ];
  }

  // XXX get le certs for ns1, ns2
  if ('ns1.redirect-www.org,ns2.redirect-www.org' === options.services.join(',')) {
    options.cacert = false;
  }

  if (!cli.token) {
    // TODO escape re, use rc.hostname
    if (!rc.token) {
      if (!(new RegExp(freedomain)).test(options.hostname)) {
        console.error("You must specify --token /path/to/sub.domain.tld.jwt");
        return;
      }
    }
    else if (!(new RegExp(rc.hostname)).test(options.hostname)) {
      console.error("The token at '" + configPath + "' does not match '" + rc.hostname + "'");
      return;
    }
  }
  options.email = options.email || rc.email;
  if ((new RegExp(freedomain)).test(options.hostname)) {
    if (!options.email) {
      console.error("[Error] You must specify a email address with --email");
      console.error("");
      console.error("our registration system is not yet complete, but we will email you when it is");
      console.error("so that you can claim your '" + freedomain + "' domain");
      return;
    }
    if (!options.agree) {
      console.error("[Error] To register a domain with us you must agree to our terms of use");
      console.error("");
      console.error("add --agree to accept the Daplie DNS terms of use");
      console.error("");
      console.error("Currently our agreement is simply: 'You will use Daplie DNS for good, not evil'.");
      console.error("We will email you when our actual legal agreement becomes available.");
      return;
    }
  }
  options.token = cli.token || rc.token || tokenPath;

  // TODO read services and token from config
  // if (!fs.existsSync('~/.node-ddns')) {
  //   console.error('You must login first: ddns login');
  //   // TODO prompt email, password, one-time
  //   // TODO npm install --save qrcode-terminal
  //   return;
  // }

  if (options.token) {
    try {
      options.token = require('fs').readFileSync(options.token, 'ascii').trim();
    } catch(e) {
      if (options.token.length < 384) {
        console.error("Could not read token file '" + options.token + "'");
        return;
      }
    }
  }

  answers = [
    { "name": options.hostname
    , "value": options.answer
    , "type": options.type
    , "priority": options.priority
    , "token": options.token // device should go here?
    , "ttl": options.ttl || undefined
    , "device": options.device || undefined
    , "email": options.email || undefined
    }
  ];

  return ddns.update({
    servers: options.services
  , port: options.port
  , cacert: options.cacert
  , pathname: options.pathname || '/api/com.daplie.dns/ddns' // TODO dns -> ddns ?
  , token: options.token
  , ddns: answers
  }).then(function (data) {
    var line;

    if (!data.every(function (records) {
      return Array.isArray(records) && records.every(function (r) {
        return r && r.value;
      });
    })) {
      console.error('[Error DDNS]:');
      console.error(JSON.stringify(data, null, '  '));
      return;
    }

    if (!Array.isArray(data)) {
      console.error('[Error] unexpected data');
      console.error(JSON.stringify(data, null, '  '));
      return;
    }

    line = 'Hostname: ' + options.hostname;
    console.log('');
    console.log(line.replace(/./g, '-'));
    console.log(line);
    // TODO fix weird double array bug
    console.log('IP Address: ' + data[0][0].value);
    console.log(line.replace(/./g, '-'));
    console.log('\n');
    console.log('Test with');
    console.log('dig ' + options.hostname + ' ' + (options.type || ''));
    console.log('\n');
    try {
      if (!(rc.hostname || rc.services || rc.token || rc.email)) {
        rc.hostname = options.hostname;
        rc.services = options.services;
        rc.token = options.token;
        rc.email = options.email;

        fs.writeFileSync(configPath, JSON.stringify(rc, null, '  '), 'ascii');
        console.log("config saved to '" + configPath + "'");
      }
    } catch(e) {
      // ignore
      console.warn("Could not write configuration file '" + configPath + "'");
    }
  }, function (err) {
    console.error('[Error] ddns-cli:');
    console.error(err.stack);
    console.error(err.data);
  });
});
